#!/usr/bin/env node

/**
 * Production-like streaming test with MCP servers
 */

import { ClaudeRunner } from '../dist/index.js'
import dotenv from 'dotenv'
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'

// Load environment variables
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
dotenv.config({ path: join(__dirname, '..', '.env') })

async function main() {
  console.log('üöÄ Starting Production-like Streaming Test')
  
  // Mimic production EdgeWorker configuration
  const config = {
    workingDirectory: '/Users/agentops/code/ceedar-new-workspaces/test-streaming',
    workspaceName: 'test-streaming',
    
    // Use similar MCP config paths as production
    mcpConfigPath: ['/Users/agentops/code/ceedarmcpconfig.json'],
    
    // Add Linear MCP server like production  
    mcpConfig: {
      "linear": {
        "type": "stdio", 
        "command": "npx",
        "args": ["-y", "@tacticlaunch/mcp-linear"],
        "env": {
          "LINEAR_API_TOKEN": process.env.LINEAR_API_TOKEN
        }
      }
    },
    
    allowedTools: ["Read", "Edit", "Bash", "Task"],
    systemPrompt: 'You are a helpful assistant.',
    
    onMessage: (message) => {
      console.log(`üìß Message: ${message.type}`)
      if (message.type === 'system') {
        console.log('üîå MCP servers loaded:', message.mcp_servers)
      }
    },
    
    onError: (error) => {
      console.error('‚ùå Error:', error.message)
    },
    
    onComplete: (messages) => {
      console.log(`‚úÖ Completed with ${messages.length} messages`)
    }
  }
  
  const runner = new ClaudeRunner(config)
  
  try {
    console.log('üîÑ Starting streaming session with MCP servers...')
    
    const sessionInfo = await runner.startStreaming('Hello! Please tell me what MCP servers and tools you have available.')
    
    console.log(`üìä Session ID: ${sessionInfo.sessionId}`)
    console.log(`üåä Is streaming: ${runner.isStreaming()}`)
    
    // Wait and check if it hangs like production
    let completed = false
    runner.on('complete', () => {
      completed = true
      console.log('‚úÖ Session completed successfully!')
    })
    
    // Wait up to 60 seconds
    for (let i = 0; i < 60; i++) {
      if (completed) break
      console.log(`‚è≥ Waiting... ${i + 1}s`)
      await new Promise(resolve => setTimeout(resolve, 1000))
    }
    
    if (!completed) {
      console.log('‚è∞ Session appears to be hanging - completing stream manually')
      runner.completeStream()
      
      // Wait another 10 seconds
      for (let i = 0; i < 10; i++) {
        if (completed) break
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
    }
    
    if (!completed) {
      console.log('‚ùå Session is definitely hanging')
      process.exit(1)
    }
    
  } catch (error) {
    console.error('üí• Test failed:', error.message)
    process.exit(1)
  }
}

main().catch(error => {
  console.error('üí• Unhandled error:', error)
  process.exit(1)
})